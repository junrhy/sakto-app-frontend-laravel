# Cursor Rules for Sakto App Laravel Frontend & Backend

## Project Overview

This is a Laravel-based project with two main components:
- **Frontend**: Laravel with Inertia.js, React, TypeScript, and Tailwind CSS
- **Backend**: Laravel API server

## Architecture & Communication Pattern

### Frontend-Backend Communication
- Frontend controllers MUST use `apiUrl` and `apiToken` from config to communicate with backend API
- Frontend should NOT call `/api/` routes directly - use routes defined in `web.php`
- Always use `Http::withToken($this->apiToken)->get/post/put/delete("{$this->apiUrl}/endpoint")`
- Include `client_identifier` (auth()->user()->identifier) in API requests where needed

### Controller Pattern
```php
<?php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Inertia\Inertia;
use Illuminate\Support\Facades\Http;

class ExampleController extends Controller
{
    protected $apiUrl, $apiToken;

    public function __construct()
    {
        $this->apiUrl = config('api.url');
        $this->apiToken = config('api.token');
    }

    public function index()
    {
        try {
            $response = Http::withToken($this->apiToken)
                ->get("{$this->apiUrl}/endpoint", [
                    'client_identifier' => auth()->user()->identifier
                ]);

            if (!$response->successful()) {
                throw new \Exception('API request failed: ' . $response->body());
            }

            return Inertia::render('ComponentName', [
                'data' => $response->json()
            ]);
        } catch (\Exception $e) {
            return response()->json(['error' => $e->getMessage()], 500);
        }
    }
}
```

## Technology Stack

### Frontend (sakto-app-frontend-laravel)
- **Framework**: Laravel 11 with Inertia.js
- **Frontend**: React 18 with TypeScript
- **Styling**: Tailwind CSS with shadcn/ui components
- **State Management**: React Context API (CartContext, ThemeProvider)
- **Authentication**: Laravel Sanctum
- **Build Tool**: Vite
- **Package Manager**: npm

### Backend (sakto-app-backend-laravel)
- **Framework**: Laravel 11 API
- **Authentication**: Laravel Sanctum
- **Database**: MySQL (via Docker)
- **API Routes**: All in `routes/api.php`
- **API Controllers**: All in `app/Http/Controllers/Api/`

## Development Environment

- **Containerization**: Docker (development environment)
- **Commands**: Run via Docker containers (e.g., `docker-compose exec app php artisan migrate`)

## Code Standards & Patterns

### PHP/Laravel Standards
- Follow PSR-12 coding standards
- Use proper namespacing
- Controllers should extend base Controller class
- Use proper exception handling with try-catch blocks
- Always validate requests using Form Request classes or inline validation
- Use Eloquent ORM for database operations
- Follow Laravel naming conventions

### TypeScript/React Standards
- Use TypeScript for all new React components
- Follow React functional component patterns with hooks
- Use proper TypeScript interfaces/types in `types/` directory
- Components should be in PascalCase
- Use proper prop typing
- Prefer composition over inheritance
- **ALWAYS create files by components** - break down functionality into separate component files
- **NO monolithic files** - avoid putting all code in one large file
- Create reusable components in `resources/js/Components/`
- Organize related components in subdirectories (e.g., `Components/Forms/`, `Components/Modals/`)

### API Integration Standards
- All frontend controllers MUST use the established API pattern
- Include proper error handling for API failures
- Use consistent response formats
- Always include authentication tokens
- Handle API timeouts gracefully

### UI/UX Standards
- Use shadcn/ui components consistently
- Follow existing dark mode patterns
- Ensure responsive design (mobile-first)
- Include proper loading states
- Use consistent spacing and typography
- Display amounts with comma separators and proper currency formatting
- **Toast messages always use sonner** - use the sonner toast library for all notifications

#### Table Styling Standards
**CRITICAL**: All tables throughout the application MUST use the consistent Card-based styling pattern for visual consistency and proper dark mode support.

**Required Table Structure**:
```tsx
import { Card, CardContent } from "@/Components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/Components/ui/table";

// ✅ CORRECT - Use Card wrapper with CardContent
<Card>
    <CardContent className="p-0">
        <Table>
            <TableHeader>
                <TableRow className="bg-gray-50 dark:bg-gray-700">
                    <TableHead className="text-gray-900 dark:text-white">Column 1</TableHead>
                    <TableHead className="text-gray-900 dark:text-white">Column 2</TableHead>
                    <TableHead className="text-gray-900 dark:text-white">Actions</TableHead>
                </TableRow>
            </TableHeader>
            <TableBody>
                {data.map((item) => (
                    <TableRow key={item.id} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                        <TableCell className="text-gray-900 dark:text-white">{item.field1}</TableCell>
                        <TableCell className="text-gray-900 dark:text-white">{item.field2}</TableCell>
                        <TableCell className="text-gray-900 dark:text-white">
                            {/* Action buttons */}
                        </TableCell>
                    </TableRow>
                ))}
            </TableBody>
        </Table>
    </CardContent>
</Card>
```

**❌ WRONG - Avoid these patterns**:
```tsx
// ❌ DON'T use simple div wrapper
<div className="rounded-md border border-gray-200 dark:border-gray-700">
    <Table>...</Table>
</div>

// ❌ DON'T use Card without CardContent
<Card>
    <Table>...</Table>
</Card>

// ❌ DON'T use CardContent without p-0
<Card>
    <CardContent>
        <Table>...</Table>
    </CardContent>
</Card>
```

**Required Table Styling Rules**:
1. **Wrapper**: Always use `<Card><CardContent className="p-0">` wrapper
2. **Header Row**: Must have `className="bg-gray-50 dark:bg-gray-700"`
3. **Header Cells**: All `<TableHead>` must have `className="text-gray-900 dark:text-white"`
4. **Body Rows**: All `<TableRow>` must have `className="hover:bg-gray-50 dark:hover:bg-gray-700"`
5. **Body Cells**: All `<TableCell>` must have `className="text-gray-900 dark:text-white"`
6. **No Individual Cell Hover**: Avoid individual cell hover effects that conflict with row hover
7. **Consistent Actions Column**: Actions column should be right-aligned with `className="text-right text-gray-900 dark:text-white"`

**Why This Pattern**:
- Provides consistent visual hierarchy with proper shadows and borders
- Ensures perfect dark mode support across all tables
- Eliminates styling inconsistencies between different table implementations
- Creates a professional, polished appearance throughout the application
- Makes maintenance easier with standardized styling

**Implementation Checklist**:
- [ ] Import Card and CardContent components
- [ ] Wrap table in Card with CardContent className="p-0"
- [ ] Apply consistent header styling (bg-gray-50 dark:bg-gray-700)
- [ ] Apply consistent header text colors (text-gray-900 dark:text-white)
- [ ] Apply consistent row hover effects (hover:bg-gray-50 dark:hover:bg-gray-700)
- [ ] Apply consistent cell text colors (text-gray-900 dark:text-white)
- [ ] Ensure no conflicting individual cell hover styles

#### shadcn/ui Select Component Best Practices
**CRITICAL**: When using the Select component from shadcn/ui, **NEVER use empty string values** for SelectItem components:

```tsx
// ❌ WRONG - This will cause an error
<SelectContent>
    <SelectItem value="">All Options</SelectItem>  // ERROR: Empty string not allowed
    <SelectItem value="option1">Option 1</SelectItem>
</SelectContent>

// ✅ CORRECT - Use meaningful non-empty values
<SelectContent>
    <SelectItem value="all">All Options</SelectItem>  // Use "all" or similar
    <SelectItem value="option1">Option 1</SelectItem>
</SelectContent>
```

**Why this happens**: The Select component reserves empty strings for clearing selections and showing placeholders. SelectItem components must have non-empty values.

**Common Solutions**:
- Use `"all"` for "All Options" or "Show All" type selections
- Use `"none"` for "None" or "No Selection" options  
- Use descriptive values like `"default"`, `"any"`, etc.
- Update filtering logic to handle the new non-empty value:

```tsx
// Update filtering logic accordingly
const filteredData = selectedValue && selectedValue !== 'all'
    ? data.filter(item => item.category === selectedValue)
    : data;
```

### File Organization
- Controllers in `app/Http/Controllers/`
- Models in `app/Models/`
- React components in `resources/js/Components/`
- Pages in `resources/js/Pages/`
- **Landing pages** in `resources/js/Pages/Landing/`
- Types in `resources/js/types/`
- Layouts in `resources/js/Layouts/`

### Landing Pages Structure
Landing pages are located in `resources/js/Pages/Landing/` and should have their own dedicated controllers:

#### Organization Pattern:
- **Landing Page Location**: `resources/js/Pages/Landing/[PageName].tsx`
- **Controller Location**: `app/Http/Controllers/[PageName]Controller.php`
- **Each landing page gets its own controller** for better organization and maintainability

#### Example:
- **Community Landing**: 
  - Page: `resources/js/Pages/Landing/Community.tsx`
  - Controller: `app/Http/Controllers/CommunityController.php`
- **Shop Landing**:
  - Page: `resources/js/Pages/Landing/Shop.tsx`
  - Controller: `app/Http/Controllers/ShopController.php`

#### Landing Page Data Handling:
In landing pages, you can retrieve user data via URL parameters and handle it in the controller:

```php
// Example: CommunityController handling user identifier from URL
public function member($identifier)
{
    // Check if identifier is numeric (ID) or string (slug)
    $member = null;
    
    if (is_numeric($identifier)) {
        // Search by ID
        $member = User::where('project_identifier', 'community')
            ->where('id', $identifier)
            ->select('id', 'name', 'email', 'contact_number', 'app_currency', 'created_at', 'identifier', 'slug')
            ->first();
    } else {
        // Search by slug
        $member = User::where('project_identifier', 'community')
            ->where('slug', $identifier)
            ->select('id', 'name', 'email', 'contact_number', 'app_currency', 'created_at', 'identifier', 'slug')
            ->first();
    }
    
    // Handle member data and return to view
    return Inertia::render('Landing/Community', [
        'member' => $member,
        // ... other data
    ]);
}
```

**Note**: This separation ensures clean code organization and allows each landing page to have its own specific logic and API integrations.

### File Upload Handling
File uploads should be handled using Laravel's storage system and saved to the public disk:

```php
// File upload pattern
if ($request->hasFile('id_picture')) {
    $path = $request->file('id_picture')->store('id_pictures', 'public');
    $validated['id_picture'] = Storage::disk('public')->url($path);
}

// Multiple file uploads
if ($request->hasFile('images')) {
    $imagePaths = [];
    foreach ($request->file('images') as $image) {
        $path = $image->store('product_images', 'public');
        $imagePaths[] = Storage::disk('public')->url($path);
    }
    $validated['images'] = $imagePaths;
}
```

#### File Upload Best Practices:
- Always use `$request->hasFile()` to check if file exists
- Store files using `store()` method with appropriate folder names
- Use `'public'` disk for publicly accessible files
- Generate URLs using `Storage::disk('public')->url($path)`
- Organize files in logical folders (e.g., 'id_pictures', 'product_images', 'documents')
- Validate file types and sizes before storing

**Note**: Files are stored in `storage/app/public/` and accessible via the public URL.

### Route Organization
Routes should be properly grouped in `routes/web.php`:

#### Public Routes Group:
- All public routes (no authentication required) should be grouped together
- Use middleware group `['web']` for public routes
- Include landing pages, policy pages, public APIs, etc.

#### Authenticated Routes Group:
- All routes requiring authentication should be grouped with appropriate middleware
- **CRITICAL**: Use middleware `['auth', 'verified', 'team.member.selection']` for all authenticated routes
- Separate groups for different permission levels (admin, subscription-required, etc.)

#### Required Middleware for Authenticated Routes:
- `'auth'` - Ensures user is authenticated
- `'verified'` - Ensures email is verified
- `'team.member.selection'` - Handles team member context (REQUIRED for all authenticated routes)

#### Example Structure:
```php
// Public routes
Route::group(['middleware' => ['web']], function () {
    Route::get('/landing', [LandingController::class, 'index']);
    Route::get('/community', [CommunityController::class, 'index']);
    // ... other public routes
});

// Authenticated routes (ALWAYS use these 3 middleware)
Route::middleware(['auth', 'verified', 'team.member.selection'])->group(function () {
    Route::get('/dashboard', [DashboardController::class, 'index']);
    // ... other authenticated routes
});

// Module routes (like clinic, pos, etc.) - MUST include all 3 middleware
Route::prefix('clinic')->middleware(['auth', 'verified', 'team.member.selection'])->group(function () {
    Route::get('/', [ClinicController::class, 'index'])->name('clinic');
    Route::post('/payment-accounts', [ClinicController::class, 'createPaymentAccount']);
    // ... other clinic routes
});

// Admin routes
Route::middleware(['auth', 'verified', 'team.member.selection', 'admin'])->group(function () {
    Route::get('/admin/dashboard', [AdminController::class, 'index']);
    // ... admin routes
});
```

#### Common Route Issues:
- **Missing Middleware**: Always include `['auth', 'verified', 'team.member.selection']` for authenticated routes
- **404 Errors**: Often caused by missing middleware or incorrect route grouping
- **Route Caching**: Clear route cache with `php artisan route:clear` after adding new routes

**Note**: This grouping ensures proper middleware application and makes route management more organized.

### Component Architecture Guidelines
- **Single Responsibility**: Each component should have one clear purpose
- **Small Components**: Keep components focused and manageable (typically under 200 lines)
- **Reusable Components**: Create generic components that can be reused across pages
- **Component Composition**: Build complex UIs by combining smaller components
- **Proper File Naming**: Use descriptive names that reflect component functionality

#### Example Component Structure:
```
Components/
├── Forms/
│   ├── LoginForm.tsx
│   ├── ContactForm.tsx
│   └── ProductForm.tsx
├── Modals/
│   ├── ConfirmDialog.tsx
│   ├── ProductModal.tsx
│   └── UserModal.tsx
├── Tables/
│   ├── DataTable.tsx
│   ├── ProductTable.tsx
│   └── UserTable.tsx
└── ui/ (shadcn/ui components)
```

### Database & Migrations
- Create migrations for all database changes
- Use proper column types and constraints
- Include foreign key relationships
- **ALWAYS ensure migration date is today's date** - create fresh migrations with current timestamp
- **In backend API: new database tables MUST have client_identifier column** for multi-tenant data isolation
- Run migrations via Docker: `docker-compose exec app php artisan migrate`

#### Creating Model, Migration, and Controller:
The most efficient way to generate all three components is by using the make:model Artisan command with the -m (migration) and -c (controller) flags. If you also need a resource controller with pre-defined methods for common CRUD operations, you can add the --resource flag or the shorthand -r.

```bash
# Basic model with migration and controller
php artisan make:model <ModelName> -mc

# Model with migration, controller, and resource methods
php artisan make:model <ModelName> -mcr

# For API controllers (backend), use the --api flag
php artisan make:model <ModelName> -mc --api

# Example for QueueType model
php artisan make:model QueueType -mc
php artisan make:model QueueNumber -mc
```

#### Additional Artisan Commands:
```bash
# Create a migration only
php artisan make:migration create_table_name

# Create a controller only
php artisan make:controller Api/ControllerName

# Create a resource controller with API methods
php artisan make:controller Api/ControllerName --api

# Create a model with factory and seeder
php artisan make:model ModelName -mf --seeder
```

#### Backend API Database Table Requirements:
```php
// Example migration for backend API
Schema::create('example_table', function (Blueprint $table) {
    $table->id();
    $table->string('client_identifier')->index(); // REQUIRED for backend API tables
    $table->string('name');
    // ... other columns
    $table->timestamps();
    
    // Index for performance
    $table->index(['client_identifier', 'created_at']);
});
```

#### Backend API Request Handling:
The `client_identifier` is always provided in API requests and should be used for data filtering.

**API Controller Location**: All backend API controllers must be created in `app/Http/Controllers/Api/`

```php
<?php
namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class ExampleController extends Controller
{
    // Example: API Controller handling client_identifier from request
    public function index(Request $request)
    {
        $clientIdentifier = $request->input('client_identifier');
        
        $data = ExampleModel::where('client_identifier', $clientIdentifier)
            ->get();
        
        return response()->json(['data' => $data]);
    }

    // Example: Storing data with client_identifier
    public function store(Request $request)
    {
        $validated = $request->validate([
            'name' => 'required|string',
            'client_identifier' => 'required|string'
        ]);
        
        $item = ExampleModel::create($validated);
        
        return response()->json(['data' => $item]);
    }
}
```

### Module Creation & Seeders
When creating new modules, **ALWAYS consider updating seeders**:

#### ModuleSeeder (`database/seeders/ModuleSeeder.php`)
- Add new module data to the `getAppsData()` method
- Include all required fields: `title`, `route`, `visible`, `description`, `price`, `categories`, etc.
- Use proper identifier generation (e.g., 'f&b' becomes 'fnb')
- Include appropriate icon suggestions
- Set correct pricing type and included plans

#### DashboardSeeder (`database/seeders/DashboardSeeder.php`)  
- Add dashboard entry for new module in the `$dashboards` array
- Use module identifier as the `app` value
- Ensure all existing users get the new dashboard

#### Module Data Structure:
```php
[
    'title' => 'Module Name',
    'route' => '/dashboard?app=module-identifier',
    'visible' => true,
    'description' => 'Module description',
    'price' => 0.00,
    'categories' => ['category1', 'category2'],
    'comingSoon' => false,
    'pricingType' => 'free', // or 'subscription', 'one-time'
    'includedInPlans' => ['basic', 'premium'],
    'bgColor' => 'bg-blue-500',
    'icon' => 'IconName',
    'rating' => 4.5
]
```

#### Route Format Requirements:
- **All module routes MUST use the dashboard query parameter format**: `/dashboard?app=module-identifier`
- **Module identifier should match the identifier generated from the title** (e.g., 'Queue System' becomes 'queue-system')
- **Examples of correct route formats**:
  - Queue System: `/dashboard?app=queue-system`
  - Mortuary: `/dashboard?app=mortuary`
  - Clinic: `/dashboard?app=clinic`
  - Lending: `/dashboard?app=lending`
- **Do NOT use direct routes** like `/queue`, `/mortuary`, etc. - always use the dashboard format

**Note**: Always run seeders after creating new modules to ensure proper system initialization.

### Cron Jobs & Scheduling
When creating cron jobs or scheduled tasks, define them in `routes/console.php`:

#### Scheduling Pattern:
```php
use Illuminate\Support\Facades\Schedule;

// Daily tasks
Schedule::command('app:your-command')->dailyAt('00:00');

// Hourly tasks  
Schedule::command('app:your-command')->hourly();

// Custom timing
Schedule::command('app:your-command')->dailyAt('09:00');
```

#### Best Practices:
- Use descriptive command names with `app:` prefix
- Set appropriate timing based on business requirements
- Consider timezone (Philippines time in examples)
- Document the purpose of each scheduled task
- Test scheduled commands thoroughly before deployment

### Categories & Data Handling
- Categories should be based solely on response data's category field
- Don't manipulate or transform category data unless explicitly required
- Preserve original API response structure for categories

### Styling Preferences
- Code blocks should not wrap lines - use horizontal scrollbars
- Maintain consistent dark mode colors across components
- Use existing color scheme and component patterns

## Common Patterns

### Error Handling
```php
try {
    $response = Http::withToken($this->apiToken)
        ->get("{$this->apiUrl}/endpoint");
    
    if (!$response->successful()) {
        throw new \Exception('API request failed: ' . $response->body());
    }
    
    return response()->json($response->json());
} catch (\Exception $e) {
    Log::error('Operation failed', [
        'error' => $e->getMessage(),
        'trace' => $e->getTraceAsString()
    ]);
    
    return response()->json([
        'status' => 'error',
        'message' => 'Operation failed',
        'data' => null
    ], 500);
}
```

### Currency Settings Pattern
```php
// Retrieve user currency settings
$jsonAppCurrency = json_decode(auth()->user()->app_currency);

// Use in data formatting
$formattedData = array_map(function($item) use ($jsonAppCurrency) {
    $item['price_formatted'] = $jsonAppCurrency->symbol . number_format(
        $item['price'], 
        2, 
        $jsonAppCurrency->decimal_separator, 
        $jsonAppCurrency->thousands_separator
    );
    return $item;
}, $data);
```

### Inertia.js Response Pattern
```php
return Inertia::render('PageName', [
    'data' => $apiResponse,
    'appCurrency' => $jsonAppCurrency,
    'categories' => $categories
]);
```

### Shared Data via HandleInertiaRequests Middleware
The following data is automatically available on all pages through `app/Http/Middleware/HandleInertiaRequests.php`:

#### Auth Data (auth.*)
- `auth.user` - Current authenticated user with properties:
  - `id`, `name`, `email`, `contact_number`
  - `identifier`, `project_identifier`
  - `app_currency` - User's currency settings (JSON string)
  - `theme`, `theme_color` - User's theme preferences
  - `is_admin` - Admin status
  - `subscription` - User's subscription data
- `auth.project` - Current project data
- `auth.modules` - Enabled modules for the project
- `auth.teamMembers` - Available team members
- `auth.selectedTeamMember` - Currently selected team member

#### App Data (app.*)
- `app.name` - Application name from config

#### Flash Messages (flash.*)
- `flash.message` - Success messages
- `flash.error` - Error messages  
- `flash.type` - Message type

#### Routing (ziggy.*)
- `ziggy` - Route data for frontend routing

**Note**: This shared data is available in all React components via props without needing to explicitly pass it from controllers.

### React Component Pattern
```tsx
import React from 'react';
import { PageProps } from '@/types';

interface Props extends PageProps {
    data: any[];
    categories: any[];
}

export default function ComponentName({ data, categories }: Props) {
    return (
        <div className="space-y-6">
            {/* Component content */}
        </div>
    );
}
```

## Security Considerations
- Always validate and sanitize input data
- Use CSRF protection for forms
- Implement proper authentication checks
- Sanitize data before displaying in frontend
- Use prepared statements for database queries
- Validate file uploads properly

## Performance Guidelines
- Use eager loading for Eloquent relationships
- Implement proper caching where appropriate
- Optimize API calls - avoid N+1 queries
- Use pagination for large datasets
- Compress and optimize images
- Use CDN for static assets

## Testing Guidelines
- Write unit tests for critical business logic
- Test API endpoints thoroughly
- Test React components with proper mocking
- Include integration tests for API communication
- Test error scenarios and edge cases
- **Always run linter test or npm lint** before committing code

## Deployment Notes
- Use environment variables for configuration
- Ensure proper Docker setup for production
- Run database migrations in production safely
- Clear caches after deployment
- Monitor API response times and errors

## Common Commands

### Docker Network Setup
Before running any Docker commands, ensure the `sakto_network` exists:
```bash
# Create the required Docker network (run once)
docker network create sakto_network

# Verify network exists
docker network ls | grep sakto
```

### Frontend (Laravel)
```bash
# Navigate to frontend directory first
cd /path/to/sakto-app-frontend-laravel

# Run migrations (service name is 'app' for frontend)
docker-compose exec app php artisan migrate

# Run seeders
docker-compose exec app php artisan db:seed --class=ModuleSeeder
docker-compose exec app php artisan db:seed --class=DashboardSeeder

# Clear caches
docker-compose exec app php artisan cache:clear
docker-compose exec app php artisan config:clear
docker-compose exec app php artisan route:clear

# Generate keys
docker-compose exec app php artisan key:generate

# Install dependencies
docker-compose exec app composer install
npm install

# Build assets
npm run build
npm run dev

# Linting
npm run lint
npm run lint:fix
```

### Backend (API)
```bash
# Navigate to backend directory first
cd /path/to/sakto-app-backend-laravel

# Run migrations (service name is 'php' for backend)
docker-compose exec php php artisan migrate

# Run seeders
docker-compose exec php php artisan db:seed

# Install dependencies
docker-compose exec php composer install
```

### Docker Container Management
```bash
# Start all containers
docker-compose up -d

# Stop all containers
docker-compose down

# View running containers
docker ps

# View container logs
docker-compose logs [service-name]

# Access container shell
docker-compose exec [service-name] bash
```

### Common Docker Issues & Solutions
1. **Network not found error**: Run `docker network create sakto_network`
2. **Service not running**: Check with `docker ps` and restart with `docker-compose up -d`
3. **Wrong service name**: Frontend uses `app`, Backend uses `php`
4. **Port conflicts**: Check if ports 8000, 8001, 3308, 3309 are available
5. **Permission issues**: Ensure Docker has proper permissions on your project directories

## Important Notes
- Always test API connectivity before implementing frontend features
- Ensure proper error messages are displayed to users
- Follow existing patterns for consistency
- Consider mobile responsiveness in all UI components
- Use proper TypeScript types for better development experience
- Maintain backward compatibility when making API changes

## Troubleshooting
- Check API connectivity if frontend requests fail
- Verify authentication tokens are properly configured
- Ensure Docker containers are running
- Check Laravel logs for detailed error information
- Verify database connections and migrations
- Check Vite build process for frontend issues
